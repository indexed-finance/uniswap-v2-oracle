{
  "language": "Solidity",
  "sources": {
    "temp-contracts/IndexedUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./lib/PriceLibrary.sol\";\nimport \"./lib/FixedPoint.sol\";\nimport \"./lib/IndexedPriceMapLibrary.sol\";\n\n/* ==========  Internal Inheritance  ========== */\nimport \"./interfaces/IIndexedUniswapV2Oracle.sol\";\n\n\ncontract IndexedUniswapV2Oracle is IIndexedUniswapV2Oracle {\n  using PriceLibrary for address;\n  using PriceLibrary for PriceLibrary.PriceObservation;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n  using IndexedPriceMapLibrary for IndexedPriceMapLibrary.IndexedPriceMap;\n\n\n/* ==========  Immutables  ========== */\n\n  address internal immutable _uniswapFactory;\n  address internal immutable _weth;\n\n/* ==========  Storage  ========== */\n\n  // Price observations for tokens indexed by hour.\n  mapping(address => IndexedPriceMapLibrary.IndexedPriceMap) internal _tokenPriceMaps;\n\n/* ==========  Modifiers  ========== */\n\n  modifier validMinMax(uint256 minTimeElapsed, uint256 maxTimeElapsed) {\n    require(\n      maxTimeElapsed >= minTimeElapsed,\n      \"IndexedUniswapV2Oracle::validMinMax: Minimum age can not be higher than maximum.\"\n    );\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  constructor(address uniswapFactory, address weth) public {\n    _uniswapFactory = uniswapFactory;\n    _weth = weth;\n  }\n\n/* ==========  Mutative Functions  ========== */\n\n  /**\n   * @dev Attempts to update the price of `token` and returns a boolean\n   * indicating whether it was updated.\n   *\n   * Note: The price can be updated if there is no observation for the current hour\n   * and at least 30 minutes have passed since the last observation.\n   */\n  function updatePrice(address token) public override returns (bool/* didUpdatePrice */) {\n    if (token == _weth) return true;\n    PriceLibrary.PriceObservation memory observation = _uniswapFactory.observeTwoWayPrice(token, _weth);\n    return _tokenPriceMaps[token].writePriceObservation(observation);\n  }\n\n  /**\n   * @dev Attempts to update the price of each token in `tokens` and returns a boolean\n   * array indicating which tokens had their prices updated.\n   *\n   * Note: The price can be updated if there is no observation for the current hour\n   * and at least 30 minutes have passed since the last observation.\n   */\n  function updatePrices(address[] calldata tokens)\n    external\n    override\n    returns (bool[] memory pricesUpdated)\n  {\n    uint256 len = tokens.length;\n    pricesUpdated = new bool[](len);\n    for (uint256 i = 0; i < len; i++) {\n      pricesUpdated[i] = updatePrice(tokens[i]);\n    }\n  }\n\n/* ==========  Meta Price Queries  ========== */\n\n  /**\n   * @dev Returns a boolean indicating whether a price was recorded for `token` at `priceKey`.\n   *\n   * @param token Token to check if the oracle has a price for\n   * @param priceKey Index of the hour to check\n   */\n  function hasPriceObservationInWindow(address token, uint256 priceKey)\n    external view override returns (bool)\n  {\n    return _tokenPriceMaps[token].hasPriceInWindow(priceKey);\n  }\n\n\n  /**\n   * @dev Returns the price observation for `token` recorded in `priceKey`.\n   * Reverts if no prices have been recorded for that key.\n   *\n   * @param token Token to retrieve a price for\n   * @param priceKey Index of the hour to query\n   */\n  function getPriceObservationInWindow(address token, uint256 priceKey)\n    external\n    view\n    override\n    returns (PriceLibrary.PriceObservation memory observation)\n  {\n    observation = _tokenPriceMaps[token].getPriceInWindow(priceKey);\n    require(\n      observation.timestamp != 0,\n      \"IndexedUniswapV2Oracle::getPriceObservationInWindow: No price observed in given hour.\"\n    );\n  }\n\n  /**\n   * @dev Returns all price observations for `token` recorded between `timeFrom` and `timeTo`.\n   */\n  function getPriceObservationsInRange(address token, uint256 timeFrom, uint256 timeTo)\n    external\n    view\n    override\n    returns (PriceLibrary.PriceObservation[] memory prices)\n  {\n    prices = _tokenPriceMaps[token].getPriceObservationsInRange(timeFrom, timeTo);\n  }\n\n/* ==========  Price Update Queries  ========== */\n\n  /**\n   * @dev Returns a boolean indicating whether the price of `token` can be updated.\n   *\n   * Note: The price can be updated if there is no observation for the current hour\n   * and at least 30 minutes have passed since the last observation.\n   */\n  function canUpdatePrice(address token) external view override returns (bool/* canUpdatePrice */) {\n    if (!_uniswapFactory.pairInitialized(token, _weth)) return false;\n    return _tokenPriceMaps[token].canUpdatePrice(uint32(now));\n  }\n\n  /**\n   * @dev Returns a boolean array indicating whether the price of each token in\n   * `tokens` can be updated.\n   *\n   * Note: The price can be updated if there is no observation for the current hour\n   * and at least 30 minutes have passed since the last observation.\n   */\n  function canUpdatePrices(address[] calldata tokens) external view override returns (bool[] memory canUpdateArr) {\n    uint256 len = tokens.length;\n    canUpdateArr = new bool[](len);\n    for (uint256 i = 0; i < len; i++) {\n      address token = tokens[i];\n      bool timeAllowed = _tokenPriceMaps[token].canUpdatePrice(uint32(now));\n      canUpdateArr[i] = timeAllowed && _uniswapFactory.pairInitialized(token, _weth);\n    }\n  }\n\n/* ==========  Price Queries: Singular  ========== */\n\n  /**\n   * @dev Returns the TwoWayAveragePrice struct representing the average price of\n   * weth in terms of `token` and the average price of `token` in terms of weth.\n   *\n   * Computes the time-weighted average price of weth in terms of `token` and the price\n   * of `token` in terms of weth by getting the current prices from Uniswap and searching\n   * for a historical price which is between `minTimeElapsed` and `maxTimeElapsed` seconds old.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeTwoWayAveragePrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (PriceLibrary.TwoWayAveragePrice memory)\n  {\n    return _getTwoWayPrice(token, minTimeElapsed, maxTimeElapsed);\n  }\n\n  /**\n   * @dev Returns the UQ112x112 struct representing the average price of\n   * `token` in terms of weth.\n   *\n   * Computes the time-weighted average price of `token` in terms of weth by getting the\n   * current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageTokenPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (FixedPoint.uq112x112 memory priceAverage)\n  {\n    return _getTokenPrice(token, minTimeElapsed, maxTimeElapsed);\n  }\n\n  /**\n   * @dev Returns the UQ112x112 struct representing the average price of\n   * weth in terms of `token`.\n   *\n   * Computes the time-weighted average price of weth in terms of `token` by getting the\n   * current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageEthPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (FixedPoint.uq112x112 memory priceAverage)\n  {\n    return _getEthPrice(token, minTimeElapsed, maxTimeElapsed);\n  }\n\n/* ==========  Price Queries: Multiple  ========== */\n\n  /**\n   * @dev Returns the TwoWayAveragePrice structs representing the average price of\n   * weth in terms of each token in `tokens` and the average price of each token\n   * in terms of weth.\n   *\n   * Computes the time-weighted average price of weth in terms of each token and the price\n   * of each token in terms of weth by getting the current prices from Uniswap and searching\n   * for a historical price which is between `minTimeElapsed` and `maxTimeElapsed` seconds old.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (PriceLibrary.TwoWayAveragePrice[] memory prices)\n  {\n    uint256 len = tokens.length;\n    prices = new PriceLibrary.TwoWayAveragePrice[](len);\n    for (uint256 i = 0; i < len; i++) {\n      prices[i] = _getTwoWayPrice(tokens[i], minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  /**\n   * @dev Returns the UQ112x112 structs representing the average price of\n   * each token in `tokens` in terms of weth.\n   *\n   * Computes the time-weighted average price of each token in terms of weth by getting\n   * the current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (FixedPoint.uq112x112[] memory averagePrices)\n  {\n    uint256 len = tokens.length;\n    averagePrices = new FixedPoint.uq112x112[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averagePrices[i] = _getTokenPrice(tokens[i], minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  /**\n   * @dev Returns the UQ112x112 structs representing the average price of\n   * weth in terms of each token in `tokens`.\n   *\n   * Computes the time-weighted average price of weth in terms of each token by getting\n   * the current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (FixedPoint.uq112x112[] memory averagePrices)\n  {\n    uint256 len = tokens.length;\n    averagePrices = new FixedPoint.uq112x112[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averagePrices[i] = _getEthPrice(tokens[i], minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n/* ==========  Value Queries: Singular  ========== */\n\n  /**\n   * @dev Compute the average value of `tokenAmount` ether in terms of weth.\n   *\n   * Computes the time-weighted average price of `token` in terms of weth by getting\n   * the current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by `wethAmount`.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (uint144 /* averageValueInWETH */)\n  {\n    FixedPoint.uq112x112 memory tokenPrice = _getTokenPrice(token, minTimeElapsed, maxTimeElapsed);\n    return tokenPrice.mul(tokenAmount).decode144();\n  }\n\n  /**\n   * @dev Compute the average value of `wethAmount` ether in terms of `token`.\n   *\n   * Computes the time-weighted average price of weth in terms of the token by getting\n   * the current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by `wethAmount`.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (uint144 /* averageValueInToken */)\n  {\n    FixedPoint.uq112x112 memory ethPrice = _getEthPrice(token, minTimeElapsed, maxTimeElapsed);\n    return ethPrice.mul(wethAmount).decode144();\n  }\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  /**\n   * @dev Compute the average value of each amount of tokens in `tokenAmounts` in terms\n   * of the corresponding token in `tokens`.\n   *\n   * Computes the time-weighted average price of each token in terms of weth by getting\n   * the current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by the corresponding\n   * amount in `tokenAmounts`.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (uint144[] memory averageValuesInWETH)\n  {\n    uint256 len = tokens.length;\n    require(\n      tokenAmounts.length == len,\n      \"IndexedUniswapV2Oracle::computeAverageEthForTokens: Tokens and amounts have different lengths.\"\n    );\n    averageValuesInWETH = new uint144[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averageValuesInWETH[i] = _getTokenPrice(\n        tokens[i],\n        minTimeElapsed,\n        maxTimeElapsed\n      ).mul(tokenAmounts[i]).decode144();\n    }\n  }\n\n  /**\n   * @dev Compute the average value of each amount of ether in `wethAmounts` in terms\n   * of the corresponding token in `tokens`.\n   *\n   * Computes the time-weighted average price of weth in terms of each token by getting\n   * the current price from Uniswap and searching for a historical price which is between\n   * `minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by the corresponding\n   * amount in `wethAmounts`.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is less than one hour.\n   * Note: `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\n   * it is less than one hour.\n   */\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    override\n    validMinMax(minTimeElapsed, maxTimeElapsed)\n    returns (uint144[] memory averageValuesInWETH)\n  {\n    uint256 len = tokens.length;\n    require(\n      wethAmounts.length == len,\n      \"IndexedUniswapV2Oracle::computeAverageTokensForEth: Tokens and amounts have different lengths.\"\n    );\n    averageValuesInWETH = new uint144[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averageValuesInWETH[i] = _getEthPrice(\n        tokens[i],\n        minTimeElapsed,\n        maxTimeElapsed\n      ).mul(wethAmounts[i]).decode144();\n    }\n  }\n\n/* ==========  Internal Functions  ========== */\n  function _getTwoWayPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (PriceLibrary.TwoWayAveragePrice memory)\n  {\n    if (token == _weth) {\n      return PriceLibrary.TwoWayAveragePrice(\n        FixedPoint.encode(1)._x,\n        FixedPoint.encode(1)._x\n      );\n    }\n    // Get the current cumulative price\n    PriceLibrary.PriceObservation memory current = _uniswapFactory.observeTwoWayPrice(token, _weth);\n    // Get the latest usable price\n    (bool foundPrice, uint256 lastPriceKey) = _tokenPriceMaps[token].getLastPriceObservation(\n      current.timestamp,\n      minTimeElapsed,\n      maxTimeElapsed\n    );\n    require(foundPrice, \"IndexedUniswapV2Oracle::_getTwoWayPrice: No price found in provided range.\");\n    PriceLibrary.PriceObservation memory previous = _tokenPriceMaps[token].priceMap[lastPriceKey];\n    return previous.computeTwoWayAveragePrice(current);\n  }\n\n  function _getTokenPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (FixedPoint.uq112x112 memory)\n  {\n    if (token == _weth) {\n      return FixedPoint.fraction(1, 1);\n    }\n    (uint32 timestamp, uint224 priceCumulativeEnd) = _uniswapFactory.observePrice(token, _weth);\n    (bool foundPrice, uint256 lastPriceKey) = _tokenPriceMaps[token].getLastPriceObservation(\n      timestamp,\n      minTimeElapsed,\n      maxTimeElapsed\n    );\n    require(foundPrice, \"IndexedUniswapV2Oracle::_getTokenPrice: No price found in provided range.\");\n    PriceLibrary.PriceObservation storage previous = _tokenPriceMaps[token].priceMap[lastPriceKey];\n    return PriceLibrary.computeAveragePrice(\n      previous.timestamp,\n      previous.priceCumulativeLast,\n      timestamp,\n      priceCumulativeEnd\n    );\n  }\n\n  function _getEthPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (FixedPoint.uq112x112 memory)\n  {\n    if (token == _weth) {\n      return FixedPoint.fraction(1, 1);\n    }\n    (uint32 timestamp, uint224 priceCumulativeEnd) = _uniswapFactory.observePrice(_weth, token);\n    (bool foundPrice, uint256 lastPriceKey) = _tokenPriceMaps[token].getLastPriceObservation(\n      timestamp,\n      minTimeElapsed,\n      maxTimeElapsed\n    );\n    require(foundPrice, \"IndexedUniswapV2Oracle::_getEthPrice: No price found in provided range.\");\n    PriceLibrary.PriceObservation storage previous = _tokenPriceMaps[token].priceMap[lastPriceKey];\n    return PriceLibrary.computeAveragePrice(\n      previous.timestamp,\n      previous.ethPriceCumulativeLast,\n      timestamp,\n      priceCumulativeEnd\n    );\n  }\n}"
    },
    "temp-contracts/lib/PriceLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\nimport \"./UniswapV2OracleLibrary.sol\";\nimport \"./UniswapV2Library.sol\";\n\n\nlibrary PriceLibrary {\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n\n/* ========= Structs ========= */\n\n  struct PriceObservation {\n    uint32 timestamp;\n    uint224 priceCumulativeLast;\n    uint224 ethPriceCumulativeLast;\n  }\n\n  /**\n   * @dev Average prices for a token in terms of weth and weth in terms of the token.\n   *\n   * Note: The average weth price is not equivalent to the reciprocal of the average\n   * token price. See the UniSwap whitepaper for more info.\n   */\n  struct TwoWayAveragePrice {\n    uint224 priceAverage;\n    uint224 ethPriceAverage;\n  }\n\n/* ========= View Functions ========= */\n\n  function pairInitialized(\n    address uniswapFactory,\n    address token,\n    address weth\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address pair = UniswapV2Library.pairFor(uniswapFactory, token, weth);\n    (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(pair).getReserves();\n    return reserve0 != 0 && reserve1 != 0;\n  }\n\n  function observePrice(\n    address uniswapFactory,\n    address tokenIn,\n    address quoteToken\n  )\n    internal\n    view\n    returns (uint32 /* timestamp */, uint224 /* priceCumulativeLast */)\n  {\n    (address token0, address token1) = UniswapV2Library.sortTokens(tokenIn, quoteToken);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    if (token0 == tokenIn) {\n      (uint256 price0Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice0(pair);\n      return (blockTimestamp, uint224(price0Cumulative));\n    } else {\n      (uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice1(pair);\n      return (blockTimestamp, uint224(price1Cumulative));\n    }\n  }\n\n  /**\n   * @dev Query the current cumulative price of a token in terms of weth\n   * and the current cumulative price of weth in terms of the token.\n   */\n  function observeTwoWayPrice(\n    address uniswapFactory,\n    address token,\n    address weth\n  ) internal view returns (PriceObservation memory) {\n    (address token0, address token1) = UniswapV2Library.sortTokens(token, weth);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    // Get the sorted token prices\n    (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n    // Check which token is weth and which is the token,\n    // then build the price observation.\n    if (token0 == token) {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price0Cumulative),\n        ethPriceCumulativeLast: uint224(price1Cumulative)\n      });\n    } else {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price1Cumulative),\n        ethPriceCumulativeLast: uint224(price0Cumulative)\n      });\n    }\n  }\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Computes the average price of a token in terms of weth\n   * and the average price of weth in terms of a token using two\n   * price observations.\n   */\n  function computeTwoWayAveragePrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (TwoWayAveragePrice memory) {\n    uint32 timeElapsed = uint32(observation2.timestamp - observation1.timestamp);\n    FixedPoint.uq112x112 memory priceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      timeElapsed\n    );\n    FixedPoint.uq112x112 memory ethPriceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      timeElapsed\n    );\n    return TwoWayAveragePrice({\n      priceAverage: priceAverage._x,\n      ethPriceAverage: ethPriceAverage._x\n    });\n  }\n\n  function computeAveragePrice(\n    uint32 timestampStart,\n    uint224 priceCumulativeStart,\n    uint32 timestampEnd,\n    uint224 priceCumulativeEnd\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      priceCumulativeStart,\n      priceCumulativeEnd,\n      uint32(timestampEnd - timestampStart)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of the token the price observations\n   * are for in terms of weth.\n   */\n  function computeAverageTokenPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of weth in terms of the token\n   * the price observations are for.\n   */\n  function computeAverageEthPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Compute the average value in weth of `tokenAmount` of the\n   * token that the average price values are for.\n   */\n  function computeAverageEthForTokens(\n    TwoWayAveragePrice memory prices,\n    uint256 tokenAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.priceAverage).mul(tokenAmount).decode144();\n  }\n\n  /**\n   * @dev Compute the average value of `wethAmount` weth in terms of\n   * the token that the average price values are for.\n   */\n  function computeAverageTokensForEth(\n    TwoWayAveragePrice memory prices,\n    uint256 wethAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.ethPriceAverage).mul(wethAmount).decode144();\n  }\n}"
    },
    "temp-contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/************************************************************************************************\nFrom https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\n\nCopied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n\nModifications:\n- Removed `sqrt` function\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n  // range: [0, 2**112 - 1]\n  // resolution: 1 / 2**112\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  // range: [0, 2**144 - 1]\n  // resolution: 1 / 2**112\n  struct uq144x112 {\n    uint _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint private constant Q112 = uint(1) << RESOLUTION;\n  uint private constant Q224 = Q112 << RESOLUTION;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 x) internal pure returns (uq112x112 memory) {\n    return uq112x112(uint224(x) << RESOLUTION);\n  }\n\n  // encodes a uint144 as a UQ144x112\n  function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n    return uq144x112(uint256(x) << RESOLUTION);\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n    require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112(self._x / uint224(x));\n  }\n\n  // multiply a UQ112x112 by a uint, returning a UQ144x112\n  // reverts on overflow\n  function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n    uint z;\n    require(\n      y == 0 || (z = uint(self._x) * y) / y == uint(self._x),\n      \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n    );\n    return uq144x112(z);\n  }\n\n  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n  // equivalent to encode(numerator).div(denominator)\n  function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n    require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n  }\n\n  // decode a UQ112x112 into a uint112 by truncating after the radix point\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  // decode a UQ144x112 into a uint144 by truncating after the radix point\n  function decode144(uq144x112 memory self) internal pure returns (uint144) {\n    return uint144(self._x >> RESOLUTION);\n  }\n\n  // take the reciprocal of a UQ112x112\n  function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n    require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n    return uq112x112(uint224(Q224 / self._x));\n  }\n}"
    },
    "temp-contracts/lib/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Interfaces  ========== */\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 6d03bede0a97c72323fa1c379ed3fdf7231d0b26.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative prices using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrices: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the first price\n  function currentCumulativePrice0(address pair)\n    internal\n    view\n    returns (uint256 price0Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice0: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the second price\n  function currentCumulativePrice1(address pair)\n    internal\n    view\n    returns (uint256 price1Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice1: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  function computeAveragePrice(\n    uint224 priceCumulativeStart,\n    uint224 priceCumulativeEnd,\n    uint32 timeElapsed\n  ) internal pure returns (FixedPoint.uq112x112 memory priceAverage) {\n    // overflow is desired.\n    priceAverage = FixedPoint.uq112x112(\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n    );\n  }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "temp-contracts/lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 87edfdcaf49ccc52591502993db4c8c08ea9eec0.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n"
    },
    "temp-contracts/lib/IndexedPriceMapLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./PriceLibrary.sol\";\nimport \"./KeyIndex.sol\";\n\n\nlibrary IndexedPriceMapLibrary {\n  using PriceLibrary for address;\n  using KeyIndex for mapping(uint256 => uint256);\n\n/* ==========  Constants  ========== */\n\n  // Period over which prices are observed, each period should have 1 price observation.\n  uint256 public constant OBSERVATION_PERIOD = 1 hours;\n\n  // Minimum time elapsed between stored price observations\n  uint256 public constant MINIMUM_OBSERVATION_DELAY = 0.5 hours;\n\n/* ==========  Struct  ========== */\n\n  struct IndexedPriceMap {\n    mapping(uint256 => uint256) keyIndex;\n    mapping(uint256 => PriceLibrary.PriceObservation) priceMap;\n  }\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Returns the price key for `timestamp`, which is the hour index.\n   */\n  function toPriceKey(uint256 timestamp) internal pure returns (uint256/* priceKey */) {\n    return timestamp / OBSERVATION_PERIOD;\n  }\n\n  /**\n   * @dev Returns the number of seconds that have passed since the beginning of the hour.\n   */\n  function timeElapsedSinceWindowStart(uint256 timestamp) internal pure returns (uint256/* timeElapsed */) {\n    return timestamp % OBSERVATION_PERIOD;\n  }\n\n/* ========= Mutative Functions ========= */\n\n  /**\n   * @dev Writes `observation` to storage if the price can be updated. If it is\n   * updated, also marks the price key for the observation as having a value in\n   * the key index.\n   *\n   * Note: The price can be updated if there is none recorded for the current\n   * hour 30 minutes have passed since the last price update.\n   * Returns a boolean indicating whether the price was updated.\n   */\n  function writePriceObservation(\n    IndexedPriceMap storage indexedPriceMap,\n    PriceLibrary.PriceObservation memory observation\n  ) internal returns (bool/* didUpdatePrice */) {\n    bool canUpdate = sufficientDelaySinceLastPrice(indexedPriceMap, observation.timestamp);\n    if (canUpdate) {\n      uint256 priceKey = toPriceKey(observation.timestamp);\n      canUpdate = indexedPriceMap.keyIndex.markSetKey(priceKey);\n      if (canUpdate) {\n        indexedPriceMap.priceMap[priceKey] = observation;\n      }\n    }\n    return canUpdate;\n  }\n\n/* ========= Price Update View Functions ========= */\n\n  /**\n   * @dev Checks whether sufficient time has passed since the beginning of the observation\n   * window or since the price recorded in the previous window (if any) for a new price\n   * to be recorded.\n   */\n  function sufficientDelaySinceLastPrice(\n    IndexedPriceMap storage indexedPriceMap,\n    uint32 newTimestamp\n  ) internal view returns (bool/* hasSufficientDelay */) {\n    uint256 priceKey = toPriceKey(newTimestamp);\n    // If half the observation period has already passed since the beginning of the\n    // current window, we can write the price without checking the previous window.\n    if (timeElapsedSinceWindowStart(newTimestamp) >= MINIMUM_OBSERVATION_DELAY) {\n      return true;\n    } else {\n      // Verify that at least half the observation period has passed since the last price observation.\n      PriceLibrary.PriceObservation storage lastObservation = indexedPriceMap.priceMap[priceKey - 1];\n      if (\n        lastObservation.timestamp == 0 ||\n        newTimestamp - lastObservation.timestamp >= MINIMUM_OBSERVATION_DELAY\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Checks if a price can be updated. PriceLibrary can be updated if there is no price\n   * observation for the current hour and at least 30 minutes have passed since the\n   * observation in the previous hour (if there is one).\n   */\n  function canUpdatePrice(\n    IndexedPriceMap storage indexedPriceMap,\n    uint32 newTimestamp\n  ) internal view returns (bool/* canUpdatePrice */) {\n    uint256 priceKey = toPriceKey(newTimestamp);\n    // Verify there is not already a price for the same observation window\n    if (indexedPriceMap.keyIndex.hasKey(priceKey)) return false;\n    return sufficientDelaySinceLastPrice(indexedPriceMap, newTimestamp);\n  }\n\n/* =========  Price View Functions  ========= */\n\n  /**\n   * @dev Checks the key index to see if a price is recorded for `priceKey`\n   */\n  function hasPriceInWindow(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 priceKey\n  ) internal view returns (bool) {\n    return indexedPriceMap.keyIndex.hasKey(priceKey);\n  }\n\n  /**\n   * @dev Returns the price observation for `priceKey`\n   */\n  function getPriceInWindow(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 priceKey\n  ) internal view returns (PriceLibrary.PriceObservation memory) {\n    return indexedPriceMap.priceMap[priceKey];\n  }\n\n  function getPriceObservationsInRange(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 timeFrom,\n    uint256 timeTo\n  )\n    internal\n    view\n    returns (PriceLibrary.PriceObservation[] memory prices)\n  {\n    uint256 priceKeyFrom = toPriceKey(timeFrom);\n    uint256 priceKeyTo = toPriceKey(timeTo);\n    require(priceKeyTo > priceKeyFrom, \"IndexedPriceMapLibrary::getPriceObservationsInRange: Invalid time range\");\n    bytes memory bitPositions = indexedPriceMap.keyIndex.getEncodedSetKeysInRange(priceKeyFrom, priceKeyTo);\n    // Divide by 2 because length is in bytes and relative indices are stored as uint16\n    uint256 len = bitPositions.length / 2;\n    prices = new PriceLibrary.PriceObservation[](len);\n    uint256 ptr;\n    assembly { ptr := add(bitPositions, 32) }\n    for (uint256 i = 0; i < len; i++) {\n      uint256 relativeIndex;\n      assembly {\n        relativeIndex := shr(0xf0, mload(ptr))\n        ptr := add(ptr, 2)\n      }\n      uint256 key = priceKeyFrom + relativeIndex;\n      prices[i] = indexedPriceMap.priceMap[key];\n    }\n  }\n\n  /**\n   * @dev Finds the most recent price observation before `timestamp` with a minimum\n   * difference in observation times of `minTimeElapsed` and a maximum difference in\n   * observation times of `maxTimeElapsed`.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is below one hour.\n   *\n   * @param indexedPriceMap Struct with the indexed price mapping for the token.\n   * @param timestamp Timestamp to search backwards from.\n   * @param minTimeElapsed Minimum time elapsed between price observations.\n   * @param maxTimeElapsed Maximum time elapsed between price observations.\n   * Only accurate to the nearest hour (rounded down) unless it is below 1 hour.\n   */\n  function getLastPriceObservation(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 timestamp,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (bool /* foundPrice */, uint256 /* lastPriceKey */)\n  {\n    uint256 priceKey = toPriceKey(timestamp);\n    uint256 windowTimeElapsed = timeElapsedSinceWindowStart(timestamp);\n    bool canBeThisWindow = minTimeElapsed <= windowTimeElapsed;\n    bool mustBeThisWindow = maxTimeElapsed <= windowTimeElapsed;\n    // If the observation window for `timestamp` could include a price observation less than `maxTimeElapsed`\n    // older than `timestamp` and the time elapsed since the beginning of the hour for `timestamp` is not higher\n    // than `maxTimeElapsed`,  any allowed price must exist in the observation window for `timestamp`.\n    if (canBeThisWindow || mustBeThisWindow) {\n      PriceLibrary.PriceObservation storage observation = indexedPriceMap.priceMap[priceKey];\n      uint32 obsTimestamp = observation.timestamp;\n      if (\n        obsTimestamp != 0 &&\n        timestamp > obsTimestamp &&\n        timestamp - obsTimestamp <= maxTimeElapsed &&\n        timestamp - obsTimestamp >= minTimeElapsed\n      ) {\n        return (true, priceKey);\n      }\n      if (mustBeThisWindow) {\n        return (false, 0);\n      }\n    }\n\n    uint256 beginSearchTime = timestamp - minTimeElapsed;\n    priceKey = toPriceKey(beginSearchTime);\n    uint256 maxDistance = toPriceKey(maxTimeElapsed);\n    return indexedPriceMap.keyIndex.findLastSetKey(priceKey, maxDistance);\n  }\n}"
    },
    "temp-contracts/lib/KeyIndex.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./Bits.sol\";\n\n\n/**\n * @dev Library for indexing keys stored in a sequential mapping for easier\n * queries.\n *\n * Every set of 256 keys in the value map is assigned a single index which\n * records set values as bits, where 1 indicates the map has a value at a given\n * key and 0 indicates it does not.\n *\n * The 'value map' is the map which stores the values with sequential keys.\n * The 'key index' is the map which records the indices for every 256 keys\n * in the value map.\n *\n * The 'key index' is the mapping which stores the indices for each 256 values\n * in the map. For example, the key '256' in the value map would have a key\n * in the key index of `1`, where the 0th bit in the index records whether a\n * value is set in the value map .\n */\nlibrary KeyIndex {\n  using Bits for uint256;\n  using Bits for bytes;\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Compute the map key for a given index key and position.\n   * Multiplies indexKey by 256 and adds indexPosition.\n   */\n  function toMapKey(uint256 indexKey, uint256 indexPosition) internal pure returns (uint256) {\n    return (indexKey * 256) + indexPosition;\n  }\n\n  /**\n   * @dev Returns the key in the key index which stores the index for the 256-bit\n   * index which includes `mapKey` and the position in the index for that key.\n   */\n  function indexKeyAndPosition(uint256 mapKey)\n    internal\n    pure\n    returns (uint256 indexKey, uint256 indexPosition)\n  {\n    indexKey = mapKey / 256;\n    indexPosition = mapKey % 256;\n  }\n\n/* ========= Mutative Functions ========= */\n\n  /**\n   * @dev Sets a bit at the position in `indexMap` corresponding to `mapKey` if the\n   * bit is not already set.\n   *\n   * @param keyIndex Mapping with indices of set keys in the value map\n   * @param mapKey Position in the value map to mark as set\n   */\n  function markSetKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey\n  ) internal returns (bool /* didSetKey */) {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    // console.log(\"IPOS\", indexPosition);\n    uint256 localIndex = keyIndex[indexKey];\n    bool canSetKey = !localIndex.bitSet(indexPosition);\n    if (canSetKey) {\n      keyIndex[indexKey] = localIndex.setBit(indexPosition);\n    }\n    return canSetKey;\n  }\n\n/* ========= View Functions ========= */\n\n  /**\n   * @dev Returns a boolean indicating whether a value is stored for `mapKey` in the map index.\n   */\n  function hasKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey\n  ) internal view returns (bool) {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    uint256 localIndex = keyIndex[indexKey];\n    if (localIndex == 0) return false;\n    return localIndex.bitSet(indexPosition);\n  }\n\n  /**\n   * @dev Returns a packed uint16 array with the offsets of all set keys\n   * between `mapKeyFrom` and `mapKeyTo`. Offsets are relative to `mapKeyFrom`\n   */\n  function getEncodedSetKeysInRange(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKeyFrom,\n    uint256 mapKeyTo\n  ) internal view returns (bytes memory bitPositions) {\n    uint256 rangeSize = mapKeyTo - mapKeyFrom;\n    (uint256 indexKeyStart, uint256 indexPositionStart) = indexKeyAndPosition(mapKeyFrom);\n    (uint256 indexKeyEnd, uint256 indexPositionEnd) = indexKeyAndPosition(mapKeyTo);\n    // Expand memory too accomodate the maximum number of bits that could be found\n    // Length is 2*range because values are stored as uint16s\n    // 30 is added because 32 bytes are stored at a time and this would go past rangeSize*2\n    // if most bits are set\n    bitPositions = new bytes((2 * rangeSize) + 30);\n    // Set the length to 0, as it is used by the `writeSetBits` fn\n    assembly { mstore(bitPositions, 0) }\n    uint256 indexKey = indexKeyStart;\n    // Clear the bits before `indexPositionStart` so they are not included in the search result\n    uint256 localIndex = keyIndex[indexKey].clearBitsBefore(indexPositionStart);\n    uint16 offset = 0;\n    // Check each index until the last one is reached\n    while (indexKey < indexKeyEnd) {\n      // Relative index is set by adding provided `offset` to the bit index\n      bitPositions.writeSetBits(localIndex, offset);\n      indexKey += 1;\n      localIndex = keyIndex[indexKey];\n      offset += 256;\n    }\n    // Clear the bits after `indexPositionEnd` before searching for set bits\n    localIndex = localIndex.clearBitsAfter(indexPositionEnd);\n    bitPositions.writeSetBits(localIndex, offset);\n  }\n\n  /**\n   * @dev Find the most recent position before `mapKey` which the index map records\n   * as having a set value. Returns the key in the value map for that position.\n   *\n   * @param keyIndex Mapping with indices of set keys in the value map\n   * @param mapKey Position in the value map to look behind\n   * @param maxDistance Maximum distance between the found value and `mapKey`\n   */\n  function findLastSetKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey,\n    uint256 maxDistance\n  )\n    internal\n    view\n    returns (bool/* found */, uint256/* mapKey */)\n  {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    uint256 distance = 0;\n    bool found;\n    uint256 position;\n    uint256 localIndex;\n    // If the position is 0, we must go to the previous index\n    if (indexPosition == 0) {\n      require(indexKey != 0, \"KeyIndex::findLastSetKey:Can not query value prior to 0.\");\n      indexKey -= 1;\n      distance = 1;\n    } else {\n      localIndex = keyIndex[indexKey];\n      (found, position) = localIndex.nextLowestBitSet(indexPosition);\n      if (found) {\n        distance += indexPosition - position;\n      } else {\n        distance += indexPosition + 1;\n        indexKey -= 1;\n      }\n    }\n\n    while (!found && distance <= maxDistance) {\n      localIndex = keyIndex[indexKey];\n      if (localIndex == 0) {\n        if (indexKey == 0) return (false, 0);\n        distance += 256;\n        indexKey -= 1;\n      } else {\n        position = localIndex.highestBitSet();\n        distance += 255 - position;\n        found = true;\n      }\n    }\n    if (distance > maxDistance) {\n      return (false, 0);\n    }\n    return (true, toMapKey(indexKey, position));\n  }\n\n  /**\n   * @dev Find the next position after `mapKey` which the index map records as\n   * having a set value. Returns the key in the value map for that position.\n   *\n   * @param keyIndex Mapping with indices of set values in the value map\n   * @param mapKey Position in the value map to look ahead\n   * @param maxDistance Maximum distance between the found value and `mapKey`\n   */\n  function findNextSetKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey,\n    uint256 maxDistance\n  )\n    internal\n    view\n    returns (bool/* found */, uint256/* mapKey */)\n  {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    uint256 distance = 0;\n    bool found;\n    uint256 position;\n    uint256 localIndex;\n    if (indexPosition == 255) {\n      indexKey += 1;\n      position = indexPosition;\n      distance = 1;\n    } else {\n      localIndex = keyIndex[indexKey];\n      (found, position) = localIndex.nextHighestBitSet(indexPosition);\n      if (found) {\n        distance += position - indexPosition;\n      } else {\n        distance += 256 - indexPosition;\n        indexKey += 1;\n      }\n    }\n    while (!found && distance <= maxDistance) {\n      localIndex = keyIndex[indexKey];\n      if (localIndex == 0) {\n        distance += 256;\n        indexKey += 1;\n      } else {\n        position = localIndex.lowestBitSet();\n        distance += position;\n        found = true;\n      }\n    }\n    if (distance > maxDistance) {\n      return (false, 0);\n    }\n    return (true, toMapKey(indexKey, position));\n  }\n}\n"
    },
    "temp-contracts/lib/Bits.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n\nlibrary Bits {\n  uint256 internal constant ONE = uint256(1);\n  uint256 internal constant ONES = uint256(~0);\n\n  /**\n   * @dev Sets the bit at the given 'index' in 'self' to '1'.\n   * Returns the modified value.\n   */\n  function setBit(uint256 self, uint256 index) internal pure returns (uint256) {\n    return self | (ONE << index);\n  }\n\n  /**\n   * @dev Returns a boolean indicating whether the bit at the given `index` in `self` is set.\n   */\n  function bitSet(uint256 self, uint256 index) internal pure returns (bool) {\n    return (self >> index) & 1 == 1;\n  }\n\n  /**\n    * @dev Clears all bits in the exclusive range [index:255]\n    */\n  function clearBitsAfter(uint256 self, uint256 index) internal pure returns (uint256) {\n    return self & (ONES >> (255 - index));\n  }\n\n  /**\n    * @dev Clears bits in the exclusive range [0:index]\n    */\n  function clearBitsBefore(uint256 self, uint256 index) internal pure returns (uint256) {\n    return self & (ONES << (index));\n  }\n\n  /**\n   * @dev Writes the index of every set bit in `val` as a uint16 in `bitPositions`.\n   * Adds `offset` to the stored bit index.\n   *\n   * `bitPositions` must have a length equal to twice the maximum number of bits that\n   * could be found plus 31. Each index is stored as a uint16 to accomodate `offset`\n   *  because this is used in functions which would otherwise need expensive methods\n   * to handle relative indices in multi-integer searches.\n   * The specified length ensures that solc will handle memory allocation, and the\n   * addition of 31 allows us to store whole words at a time.\n   * After being declared, the actual length stored in memory must be set to 0 with:\n   * `assembly { mstore(bitPositions, 0) }` because the length is used to count found bits.\n   *\n   * @param bitPositions Packed uint16 array for positions of set bits\n   * @param val Value to search set bits in\n   * @param offset Value added to the stored position, used to simplify large searches.\n   */\n  function writeSetBits(bytes memory bitPositions, uint256 val, uint16 offset) internal pure {\n    if (val == 0) return;\n\n    assembly {\n      // Read the current length, which is the number of stored bytes\n      let len := mload(bitPositions)\n      // Set the starting pointer by adding the length to the bytes data pointer\n      // This does not change and is later used to compute the new length\n      let startPtr := add(add(bitPositions, 32), len)\n      // Set the variable pointer which is used to track where to write memory values\n      let ptr := startPtr\n      // Increment the number of bits to shift until the shifted integer is 0\n      // Add 3 to the index each loop because that is the number of bits being checked\n      // at a time.\n      for {let i := 0} gt(shr(i, val), 0) {i := add(i, 3)} {\n        // Loop until the last 8 bits are not all 0\n        for {} eq(and(shr(i, val), 255), 0) {i := add(i, 8)} {}\n        // Take only the last 3  bits\n        let x := and(shr(i, val), 7)\n        // Use a switch statement as a lookup table with every possible combination of 3 bits.\n        switch x\n          case 0 {}// no bits set\n          case 1 {// bit 0 set\n            // shift left 240 bits to write uint16, increment ptr by 2 bytes\n            mstore(ptr, shl(0xf0, add(i, offset)))\n            ptr := add(ptr, 2)\n          }\n          case 2 {// bit 1 set\n            // shift left 240 bits to write uint16, increment ptr by 2 bytes\n            mstore(ptr, shl(0xf0, add(add(i, 1), offset)))\n            ptr := add(ptr, 2)\n          }\n          case 3 {// bits 0,1 set\n            // shift first left 240 bits and second 224 to write two uint16s\n            // increment ptr by 4 bytes\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(i, offset)),\n                shl(0xe0, add(add(i, 1), offset))\n              )\n            )\n            ptr := add(ptr, 4)\n          }\n          case 4 {// bit 2 set\n            // shift left 240 bits to write uint16, increment ptr by 2 bytes\n            mstore(ptr, shl(0xf0, add(add(i, 2), offset)))\n            ptr := add(ptr, 2)\n          }\n          case 5 {// 5: bits 0,2 set\n            // shift first left 240 bits and second 224 bits to write two uint16s\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(i, offset)),\n                shl(0xe0, add(add(i, 2), offset))\n              )\n            )\n\n            ptr := add(ptr, 4)// increment ptr by 4 bytes\n          }\n          case 6 {// bits 1,2 set\n            // shift first left 240 bits and second 224 to write two uint16s\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(add(i, 1), offset)),\n                shl(0xe0, add(add(i, 2), offset))\n              )\n            )\n            ptr := add(ptr, 4)// increment ptr by 4 bytes\n          }\n          case 7 {//bits 0,1,2 set\n            // shift first left 240 bits, second 224, third 208 to write three uint16s\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(i, offset)),\n                or(\n                  shl(0xe0, add(add(i, 1), offset)),\n                  shl(0xd0, add(add(i, 2), offset))\n                )\n              )\n            )\n            ptr := add(ptr, 6)// increment ptr by 6 bytes\n          }\n      }\n      // subtract current pointer from initial to get byte length\n      let newLen := sub(ptr, startPtr)\n      // write byte length\n      mstore(bitPositions, add(len, newLen))\n    }\n  }\n\n  /**\n   * @dev Returns the index of the highest bit set in `self`.\n   * Note: Requires that `self != 0`\n   */\n  function highestBitSet(uint256 self) internal pure returns (uint256 r) {\n    uint256 x = self;\n    require (x > 0, \"Bits::highestBitSet: Value 0 has no bits set\");\n    if (x >= 0x100000000000000000000000000000000) {x >>= 128; r += 128;}\n    if (x >= 0x10000000000000000) {x >>= 64; r += 64;}\n    if (x >= 0x100000000) {x >>= 32; r += 32;}\n    if (x >= 0x10000) {x >>= 16; r += 16;}\n    if (x >= 0x100) {x >>= 8; r += 8;}\n    if (x >= 0x10) {x >>= 4; r += 4;}\n    if (x >= 0x4) {x >>= 2; r += 2;}\n    if (x >= 0x2) r += 1; // No need to shift x anymore\n  }\n\n  /**\n   * @dev Returns the index of the lowest bit set in `self`.\n   * Note: Requires that `self != 0`\n   */\n  function lowestBitSet(uint256 self) internal pure returns (uint256 _z) {\n    require (self > 0, \"Bits::lowestBitSet: Value 0 has no bits set\");\n    uint256 _magic = 0x00818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\n    uint256 val = (self & -self) * _magic >> 248;\n    uint256 _y = val >> 5;\n    _z = (\n      _y < 4\n        ? _y < 2\n          ? _y == 0\n            ? 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\n            : 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\n          : _y == 2\n            ? 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\n            : 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\n        : _y < 6\n          ? _y == 4\n            ? 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\n            : 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\n          : _y == 6\n            ? 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\n            : 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\n    );\n    _z >>= (val & 0x1f) << 3;\n    return _z & 0xff;\n  }\n\n  /**\n   * @dev Returns a boolean indicating whether `bit` is the highest set bit\n   * in the integer and the index of the next lowest set bit if it is not.\n   */\n  function nextLowestBitSet(uint256 self, uint256 bit)\n    internal\n    pure\n    returns (bool haveValueBefore, uint256 previousBit)\n  {\n    uint256 val = self << (256 - bit);\n    if (val == 0) {\n      return (false, 0);\n    }\n    return (true, (highestBitSet(val) - (256 - bit)));\n  }\n\n  /**\n   * @dev Returns a boolean indicating whether `bit` is the lowest set bit\n   * in the integer and the index of the next highest set bit if it is not.\n   */\n  function nextHighestBitSet(uint256 self, uint256 bit)\n    internal\n    pure\n    returns (bool haveValueAfter, uint256 nextBit)\n  {\n    uint256 val = self >> (bit + 1);\n    if (val == 0) {\n      return (false, 0);\n    }\n    return (true, lowestBitSet(val) + (bit + 1));\n  }\n}\n"
    },
    "temp-contracts/interfaces/IIndexedUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Libraries  ========== */\nimport \"../lib/PriceLibrary.sol\";\nimport \"../lib/FixedPoint.sol\";\n\n\ninterface IIndexedUniswapV2Oracle {\n/* ==========  Mutative Functions  ========== */\n\n  function updatePrice(address token) external returns (bool);\n\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory);\n\n/* ==========  Meta Price Queries  ========== */\n\n  function hasPriceObservationInWindow(address token, uint256 priceKey) external view returns (bool);\n\n  function getPriceObservationInWindow(\n    address token, uint256 priceKey\n  ) external view returns (PriceLibrary.PriceObservation memory);\n\n  function getPriceObservationsInRange(\n    address token, uint256 timeFrom, uint256 timeTo\n  ) external view returns (PriceLibrary.PriceObservation[] memory prices);\n\n/* ==========  Price Update Queries  ========== */\n\n  function canUpdatePrice(address token) external view returns (bool);\n\n  function canUpdatePrices(address[] calldata tokens) external view returns (bool[] memory);\n\n/* ==========  Price Queries: Singular  ========== */\n\n  function computeTwoWayAveragePrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice memory);\n\n  function computeAverageTokenPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n  function computeAverageEthPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n/* ==========  Price Queries: Multiple  ========== */\n\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice[] memory);\n\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n/* ==========  Value Queries: Singular  ========== */\n\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}