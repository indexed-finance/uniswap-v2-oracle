{
  "language": "Solidity",
  "sources": {
    "temp-contracts/interfaces/IIndexedUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Libraries  ========== */\nimport \"../lib/PriceLibrary.sol\";\nimport \"../lib/FixedPoint.sol\";\n\n\ninterface IIndexedUniswapV2Oracle {\n/* ==========  Mutative Functions  ========== */\n\n  function updatePrice(address token) external returns (bool);\n\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory);\n\n/* ==========  Meta Price Queries  ========== */\n\n  function hasPriceObservationInWindow(address token, uint256 priceKey) external view returns (bool);\n\n  function getPriceObservationInWindow(\n    address token, uint256 priceKey\n  ) external view returns (PriceLibrary.PriceObservation memory);\n\n  function getPriceObservationsInRange(\n    address token, uint256 timeFrom, uint256 timeTo\n  ) external view returns (PriceLibrary.PriceObservation[] memory prices);\n\n/* ==========  Price Update Queries  ========== */\n\n  function canUpdatePrice(address token) external view returns (bool);\n\n  function canUpdatePrices(address[] calldata tokens) external view returns (bool[] memory);\n\n/* ==========  Price Queries: Singular  ========== */\n\n  function computeTwoWayAveragePrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice memory);\n\n  function computeAverageTokenPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n  function computeAverageEthPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n/* ==========  Price Queries: Multiple  ========== */\n\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice[] memory);\n\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n/* ==========  Value Queries: Singular  ========== */\n\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n}"
    },
    "temp-contracts/lib/PriceLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\nimport \"./UniswapV2OracleLibrary.sol\";\nimport \"./UniswapV2Library.sol\";\n\n\nlibrary PriceLibrary {\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n\n/* ========= Structs ========= */\n\n  struct PriceObservation {\n    uint32 timestamp;\n    uint224 priceCumulativeLast;\n    uint224 ethPriceCumulativeLast;\n  }\n\n  /**\n   * @dev Average prices for a token in terms of weth and weth in terms of the token.\n   *\n   * Note: The average weth price is not equivalent to the reciprocal of the average\n   * token price. See the UniSwap whitepaper for more info.\n   */\n  struct TwoWayAveragePrice {\n    uint224 priceAverage;\n    uint224 ethPriceAverage;\n  }\n\n/* ========= View Functions ========= */\n\n  function pairInitialized(\n    address uniswapFactory,\n    address token,\n    address weth\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address pair = UniswapV2Library.pairFor(uniswapFactory, token, weth);\n    (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(pair).getReserves();\n    return reserve0 != 0 && reserve1 != 0;\n  }\n\n  function observePrice(\n    address uniswapFactory,\n    address tokenIn,\n    address quoteToken\n  )\n    internal\n    view\n    returns (uint32 /* timestamp */, uint224 /* priceCumulativeLast */)\n  {\n    (address token0, address token1) = UniswapV2Library.sortTokens(tokenIn, quoteToken);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    if (token0 == tokenIn) {\n      (uint256 price0Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice0(pair);\n      return (blockTimestamp, uint224(price0Cumulative));\n    } else {\n      (uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice1(pair);\n      return (blockTimestamp, uint224(price1Cumulative));\n    }\n  }\n\n  /**\n   * @dev Query the current cumulative price of a token in terms of weth\n   * and the current cumulative price of weth in terms of the token.\n   */\n  function observeTwoWayPrice(\n    address uniswapFactory,\n    address token,\n    address weth\n  ) internal view returns (PriceObservation memory) {\n    (address token0, address token1) = UniswapV2Library.sortTokens(token, weth);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    // Get the sorted token prices\n    (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n    // Check which token is weth and which is the token,\n    // then build the price observation.\n    if (token0 == token) {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price0Cumulative),\n        ethPriceCumulativeLast: uint224(price1Cumulative)\n      });\n    } else {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price1Cumulative),\n        ethPriceCumulativeLast: uint224(price0Cumulative)\n      });\n    }\n  }\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Computes the average price of a token in terms of weth\n   * and the average price of weth in terms of a token using two\n   * price observations.\n   */\n  function computeTwoWayAveragePrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (TwoWayAveragePrice memory) {\n    uint32 timeElapsed = uint32(observation2.timestamp - observation1.timestamp);\n    FixedPoint.uq112x112 memory priceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      timeElapsed\n    );\n    FixedPoint.uq112x112 memory ethPriceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      timeElapsed\n    );\n    return TwoWayAveragePrice({\n      priceAverage: priceAverage._x,\n      ethPriceAverage: ethPriceAverage._x\n    });\n  }\n\n  function computeAveragePrice(\n    uint32 timestampStart,\n    uint224 priceCumulativeStart,\n    uint32 timestampEnd,\n    uint224 priceCumulativeEnd\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      priceCumulativeStart,\n      priceCumulativeEnd,\n      uint32(timestampEnd - timestampStart)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of the token the price observations\n   * are for in terms of weth.\n   */\n  function computeAverageTokenPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of weth in terms of the token\n   * the price observations are for.\n   */\n  function computeAverageEthPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Compute the average value in weth of `tokenAmount` of the\n   * token that the average price values are for.\n   */\n  function computeAverageEthForTokens(\n    TwoWayAveragePrice memory prices,\n    uint256 tokenAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.priceAverage).mul(tokenAmount).decode144();\n  }\n\n  /**\n   * @dev Compute the average value of `wethAmount` weth in terms of\n   * the token that the average price values are for.\n   */\n  function computeAverageTokensForEth(\n    TwoWayAveragePrice memory prices,\n    uint256 wethAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.ethPriceAverage).mul(wethAmount).decode144();\n  }\n}"
    },
    "temp-contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"./FullMath.sol\";\n\n\n/************************************************************************************************\nFrom https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\n\nCopied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n\nModifications:\n- Removed `sqrt` function\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n  using FullMath for uint256;\n\n  // range: [0, 2**112 - 1]\n  // resolution: 1 / 2**112\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  // range: [0, 2**144 - 1]\n  // resolution: 1 / 2**112\n  struct uq144x112 {\n    uint _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint private constant Q112 = uint(1) << RESOLUTION;\n  uint private constant Q224 = Q112 << RESOLUTION;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 x) internal pure returns (uq112x112 memory) {\n    return uq112x112(uint224(x) << RESOLUTION);\n  }\n\n  // encodes a uint144 as a UQ144x112\n  function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n    return uq144x112(uint256(x) << RESOLUTION);\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n    require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112(self._x / uint224(x));\n  }\n\n  // multiply a UQ112x112 by a uint, returning a UQ144x112\n  // reverts on overflow\n  function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n    uint z;\n    require(\n      y == 0 || (z = uint(self._x) * y) / y == uint(self._x),\n      \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n    );\n    return uq144x112(z);\n  }\n\n  // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n  // reverts on overflow\n  function mul(uq112x112 memory self, uq112x112 memory y) internal pure returns (uq112x112 memory) {\n    uint224 z = uint224(uint256(self._x).mulDiv(y._x, Q112));\n    return uq112x112(z);\n  }\n\n  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n  // equivalent to encode(numerator).div(denominator)\n  function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n    require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n  }\n\n  // decode a UQ112x112 into a uint112 by truncating after the radix point\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  // decode a UQ144x112 into a uint144 by truncating after the radix point\n  function decode144(uq144x112 memory self) internal pure returns (uint144) {\n    return uint144(self._x >> RESOLUTION);\n  }\n\n  // take the reciprocal of a UQ112x112\n  function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n    require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n    return uq112x112(uint224(Q224 / self._x));\n  }\n}"
    },
    "temp-contracts/lib/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "temp-contracts/lib/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Interfaces  ========== */\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 6d03bede0a97c72323fa1c379ed3fdf7231d0b26.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative prices using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrices: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the first price\n  function currentCumulativePrice0(address pair)\n    internal\n    view\n    returns (uint256 price0Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice0: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the second price\n  function currentCumulativePrice1(address pair)\n    internal\n    view\n    returns (uint256 price1Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice1: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  function computeAveragePrice(\n    uint224 priceCumulativeStart,\n    uint224 priceCumulativeEnd,\n    uint32 timeElapsed\n  ) internal pure returns (FixedPoint.uq112x112 memory priceAverage) {\n    // overflow is desired.\n    priceAverage = FixedPoint.uq112x112(\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n    );\n  }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "temp-contracts/lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 87edfdcaf49ccc52591502993db4c8c08ea9eec0.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n"
    },
    "temp-contracts/lib/Bits.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n\nlibrary Bits {\n  uint256 internal constant ONE = uint256(1);\n  uint256 internal constant ONES = uint256(~0);\n\n  /**\n   * @dev Sets the bit at the given 'index' in 'self' to '1'.\n   * Returns the modified value.\n   */\n  function setBit(uint256 self, uint256 index) internal pure returns (uint256) {\n    return self | (ONE << index);\n  }\n\n  /**\n   * @dev Returns a boolean indicating whether the bit at the given `index` in `self` is set.\n   */\n  function bitSet(uint256 self, uint256 index) internal pure returns (bool) {\n    return (self >> index) & 1 == 1;\n  }\n\n  /**\n    * @dev Clears all bits in the exclusive range [index:255]\n    */\n  function clearBitsAfter(uint256 self, uint256 index) internal pure returns (uint256) {\n    return self & (ONES >> (255 - index));\n  }\n\n  /**\n    * @dev Clears bits in the exclusive range [0:index]\n    */\n  function clearBitsBefore(uint256 self, uint256 index) internal pure returns (uint256) {\n    return self & (ONES << (index));\n  }\n\n  /**\n   * @dev Writes the index of every set bit in `val` as a uint16 in `bitPositions`.\n   * Adds `offset` to the stored bit index.\n   *\n   * `bitPositions` must have a length equal to twice the maximum number of bits that\n   * could be found plus 31. Each index is stored as a uint16 to accomodate `offset`\n   *  because this is used in functions which would otherwise need expensive methods\n   * to handle relative indices in multi-integer searches.\n   * The specified length ensures that solc will handle memory allocation, and the\n   * addition of 31 allows us to store whole words at a time.\n   * After being declared, the actual length stored in memory must be set to 0 with:\n   * `assembly { mstore(bitPositions, 0) }` because the length is used to count found bits.\n   *\n   * @param bitPositions Packed uint16 array for positions of set bits\n   * @param val Value to search set bits in\n   * @param offset Value added to the stored position, used to simplify large searches.\n   */\n  function writeSetBits(bytes memory bitPositions, uint256 val, uint16 offset) internal pure {\n    if (val == 0) return;\n\n    assembly {\n      // Read the current length, which is the number of stored bytes\n      let len := mload(bitPositions)\n      // Set the starting pointer by adding the length to the bytes data pointer\n      // This does not change and is later used to compute the new length\n      let startPtr := add(add(bitPositions, 32), len)\n      // Set the variable pointer which is used to track where to write memory values\n      let ptr := startPtr\n      // Increment the number of bits to shift until the shifted integer is 0\n      // Add 3 to the index each loop because that is the number of bits being checked\n      // at a time.\n      for {let i := 0} gt(shr(i, val), 0) {i := add(i, 3)} {\n        // Loop until the last 8 bits are not all 0\n        for {} eq(and(shr(i, val), 255), 0) {i := add(i, 8)} {}\n        // Take only the last 3  bits\n        let x := and(shr(i, val), 7)\n        // Use a switch statement as a lookup table with every possible combination of 3 bits.\n        switch x\n          case 0 {}// no bits set\n          case 1 {// bit 0 set\n            // shift left 240 bits to write uint16, increment ptr by 2 bytes\n            mstore(ptr, shl(0xf0, add(i, offset)))\n            ptr := add(ptr, 2)\n          }\n          case 2 {// bit 1 set\n            // shift left 240 bits to write uint16, increment ptr by 2 bytes\n            mstore(ptr, shl(0xf0, add(add(i, 1), offset)))\n            ptr := add(ptr, 2)\n          }\n          case 3 {// bits 0,1 set\n            // shift first left 240 bits and second 224 to write two uint16s\n            // increment ptr by 4 bytes\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(i, offset)),\n                shl(0xe0, add(add(i, 1), offset))\n              )\n            )\n            ptr := add(ptr, 4)\n          }\n          case 4 {// bit 2 set\n            // shift left 240 bits to write uint16, increment ptr by 2 bytes\n            mstore(ptr, shl(0xf0, add(add(i, 2), offset)))\n            ptr := add(ptr, 2)\n          }\n          case 5 {// 5: bits 0,2 set\n            // shift first left 240 bits and second 224 bits to write two uint16s\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(i, offset)),\n                shl(0xe0, add(add(i, 2), offset))\n              )\n            )\n\n            ptr := add(ptr, 4)// increment ptr by 4 bytes\n          }\n          case 6 {// bits 1,2 set\n            // shift first left 240 bits and second 224 to write two uint16s\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(add(i, 1), offset)),\n                shl(0xe0, add(add(i, 2), offset))\n              )\n            )\n            ptr := add(ptr, 4)// increment ptr by 4 bytes\n          }\n          case 7 {//bits 0,1,2 set\n            // shift first left 240 bits, second 224, third 208 to write three uint16s\n            mstore(\n              ptr,\n              or(// use OR to avoid multiple memory writes\n                shl(0xf0, add(i, offset)),\n                or(\n                  shl(0xe0, add(add(i, 1), offset)),\n                  shl(0xd0, add(add(i, 2), offset))\n                )\n              )\n            )\n            ptr := add(ptr, 6)// increment ptr by 6 bytes\n          }\n      }\n      // subtract current pointer from initial to get byte length\n      let newLen := sub(ptr, startPtr)\n      // write byte length\n      mstore(bitPositions, add(len, newLen))\n    }\n  }\n\n  /**\n   * @dev Returns the index of the highest bit set in `self`.\n   * Note: Requires that `self != 0`\n   */\n  function highestBitSet(uint256 self) internal pure returns (uint256 r) {\n    uint256 x = self;\n    require (x > 0, \"Bits::highestBitSet: Value 0 has no bits set\");\n    if (x >= 0x100000000000000000000000000000000) {x >>= 128; r += 128;}\n    if (x >= 0x10000000000000000) {x >>= 64; r += 64;}\n    if (x >= 0x100000000) {x >>= 32; r += 32;}\n    if (x >= 0x10000) {x >>= 16; r += 16;}\n    if (x >= 0x100) {x >>= 8; r += 8;}\n    if (x >= 0x10) {x >>= 4; r += 4;}\n    if (x >= 0x4) {x >>= 2; r += 2;}\n    if (x >= 0x2) r += 1; // No need to shift x anymore\n  }\n\n  /**\n   * @dev Returns the index of the lowest bit set in `self`.\n   * Note: Requires that `self != 0`\n   */\n  function lowestBitSet(uint256 self) internal pure returns (uint256 _z) {\n    require (self > 0, \"Bits::lowestBitSet: Value 0 has no bits set\");\n    uint256 _magic = 0x00818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\n    uint256 val = (self & -self) * _magic >> 248;\n    uint256 _y = val >> 5;\n    _z = (\n      _y < 4\n        ? _y < 2\n          ? _y == 0\n            ? 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\n            : 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\n          : _y == 2\n            ? 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\n            : 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\n        : _y < 6\n          ? _y == 4\n            ? 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\n            : 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\n          : _y == 6\n            ? 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\n            : 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\n    );\n    _z >>= (val & 0x1f) << 3;\n    return _z & 0xff;\n  }\n\n  /**\n   * @dev Returns a boolean indicating whether `bit` is the highest set bit\n   * in the integer and the index of the next lowest set bit if it is not.\n   */\n  function nextLowestBitSet(uint256 self, uint256 bit)\n    internal\n    pure\n    returns (bool haveValueBefore, uint256 previousBit)\n  {\n    uint256 val = self << (256 - bit);\n    if (val == 0) {\n      return (false, 0);\n    }\n    return (true, (highestBitSet(val) - (256 - bit)));\n  }\n\n  /**\n   * @dev Returns a boolean indicating whether `bit` is the lowest set bit\n   * in the integer and the index of the next highest set bit if it is not.\n   */\n  function nextHighestBitSet(uint256 self, uint256 bit)\n    internal\n    pure\n    returns (bool haveValueAfter, uint256 nextBit)\n  {\n    uint256 val = self >> (bit + 1);\n    if (val == 0) {\n      return (false, 0);\n    }\n    return (true, lowestBitSet(val) + (bit + 1));\n  }\n}\n"
    },
    "temp-contracts/lib/IndexedPriceMapLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./PriceLibrary.sol\";\nimport \"./KeyIndex.sol\";\n\n\nlibrary IndexedPriceMapLibrary {\n  using PriceLibrary for address;\n  using KeyIndex for mapping(uint256 => uint256);\n\n/* ==========  Constants  ========== */\n\n  // Period over which prices are observed, each period should have 1 price observation.\n  uint256 public constant OBSERVATION_PERIOD = 1 hours;\n\n  // Minimum time elapsed between stored price observations\n  uint256 public constant MINIMUM_OBSERVATION_DELAY = 0.5 hours;\n\n/* ==========  Struct  ========== */\n\n  struct IndexedPriceMap {\n    mapping(uint256 => uint256) keyIndex;\n    mapping(uint256 => PriceLibrary.PriceObservation) priceMap;\n  }\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Returns the price key for `timestamp`, which is the hour index.\n   */\n  function toPriceKey(uint256 timestamp) internal pure returns (uint256/* priceKey */) {\n    return timestamp / OBSERVATION_PERIOD;\n  }\n\n  /**\n   * @dev Returns the number of seconds that have passed since the beginning of the hour.\n   */\n  function timeElapsedSinceWindowStart(uint256 timestamp) internal pure returns (uint256/* timeElapsed */) {\n    return timestamp % OBSERVATION_PERIOD;\n  }\n\n/* ========= Mutative Functions ========= */\n\n  /**\n   * @dev Writes `observation` to storage if the price can be updated. If it is\n   * updated, also marks the price key for the observation as having a value in\n   * the key index.\n   *\n   * Note: The price can be updated if there is none recorded for the current\n   * hour 30 minutes have passed since the last price update.\n   * Returns a boolean indicating whether the price was updated.\n   */\n  function writePriceObservation(\n    IndexedPriceMap storage indexedPriceMap,\n    PriceLibrary.PriceObservation memory observation\n  ) internal returns (bool/* didUpdatePrice */) {\n    bool canUpdate = sufficientDelaySinceLastPrice(indexedPriceMap, observation.timestamp);\n    if (canUpdate) {\n      uint256 priceKey = toPriceKey(observation.timestamp);\n      canUpdate = indexedPriceMap.keyIndex.markSetKey(priceKey);\n      if (canUpdate) {\n        indexedPriceMap.priceMap[priceKey] = observation;\n      }\n    }\n    return canUpdate;\n  }\n\n/* ========= Price Update View Functions ========= */\n\n  /**\n   * @dev Checks whether sufficient time has passed since the beginning of the observation\n   * window or since the price recorded in the previous window (if any) for a new price\n   * to be recorded.\n   */\n  function sufficientDelaySinceLastPrice(\n    IndexedPriceMap storage indexedPriceMap,\n    uint32 newTimestamp\n  ) internal view returns (bool/* hasSufficientDelay */) {\n    uint256 priceKey = toPriceKey(newTimestamp);\n    // If half the observation period has already passed since the beginning of the\n    // current window, we can write the price without checking the previous window.\n    if (timeElapsedSinceWindowStart(newTimestamp) >= MINIMUM_OBSERVATION_DELAY) {\n      return true;\n    } else {\n      // Verify that at least half the observation period has passed since the last price observation.\n      PriceLibrary.PriceObservation storage lastObservation = indexedPriceMap.priceMap[priceKey - 1];\n      if (\n        lastObservation.timestamp == 0 ||\n        newTimestamp - lastObservation.timestamp >= MINIMUM_OBSERVATION_DELAY\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Checks if a price can be updated. PriceLibrary can be updated if there is no price\n   * observation for the current hour and at least 30 minutes have passed since the\n   * observation in the previous hour (if there is one).\n   */\n  function canUpdatePrice(\n    IndexedPriceMap storage indexedPriceMap,\n    uint32 newTimestamp\n  ) internal view returns (bool/* canUpdatePrice */) {\n    uint256 priceKey = toPriceKey(newTimestamp);\n    // Verify there is not already a price for the same observation window\n    if (indexedPriceMap.keyIndex.hasKey(priceKey)) return false;\n    return sufficientDelaySinceLastPrice(indexedPriceMap, newTimestamp);\n  }\n\n/* =========  Price View Functions  ========= */\n\n  /**\n   * @dev Checks the key index to see if a price is recorded for `priceKey`\n   */\n  function hasPriceInWindow(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 priceKey\n  ) internal view returns (bool) {\n    return indexedPriceMap.keyIndex.hasKey(priceKey);\n  }\n\n  /**\n   * @dev Returns the price observation for `priceKey`\n   */\n  function getPriceInWindow(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 priceKey\n  ) internal view returns (PriceLibrary.PriceObservation memory) {\n    return indexedPriceMap.priceMap[priceKey];\n  }\n\n  function getPriceObservationsInRange(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 timeFrom,\n    uint256 timeTo\n  )\n    internal\n    view\n    returns (PriceLibrary.PriceObservation[] memory prices)\n  {\n    uint256 priceKeyFrom = toPriceKey(timeFrom);\n    uint256 priceKeyTo = toPriceKey(timeTo);\n    require(priceKeyTo > priceKeyFrom, \"IndexedPriceMapLibrary::getPriceObservationsInRange: Invalid time range\");\n    bytes memory bitPositions = indexedPriceMap.keyIndex.getEncodedSetKeysInRange(priceKeyFrom, priceKeyTo);\n    // Divide by 2 because length is in bytes and relative indices are stored as uint16\n    uint256 len = bitPositions.length / 2;\n    prices = new PriceLibrary.PriceObservation[](len);\n    uint256 ptr;\n    assembly { ptr := add(bitPositions, 32) }\n    for (uint256 i = 0; i < len; i++) {\n      uint256 relativeIndex;\n      assembly {\n        relativeIndex := shr(0xf0, mload(ptr))\n        ptr := add(ptr, 2)\n      }\n      uint256 key = priceKeyFrom + relativeIndex;\n      prices[i] = indexedPriceMap.priceMap[key];\n    }\n  }\n\n  /**\n   * @dev Finds the most recent price observation before `timestamp` with a minimum\n   * difference in observation times of `minTimeElapsed` and a maximum difference in\n   * observation times of `maxTimeElapsed`.\n   *\n   * Note: `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\n   * it is below one hour.\n   *\n   * @param indexedPriceMap Struct with the indexed price mapping for the token.\n   * @param timestamp Timestamp to search backwards from.\n   * @param minTimeElapsed Minimum time elapsed between price observations.\n   * @param maxTimeElapsed Maximum time elapsed between price observations.\n   * Only accurate to the nearest hour (rounded down) unless it is below 1 hour.\n   */\n  function getLastPriceObservation(\n    IndexedPriceMap storage indexedPriceMap,\n    uint256 timestamp,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (bool /* foundPrice */, uint256 /* lastPriceKey */)\n  {\n    uint256 priceKey = toPriceKey(timestamp);\n    uint256 windowTimeElapsed = timeElapsedSinceWindowStart(timestamp);\n    bool canBeThisWindow = minTimeElapsed <= windowTimeElapsed;\n    bool mustBeThisWindow = maxTimeElapsed <= windowTimeElapsed;\n    // If the observation window for `timestamp` could include a price observation less than `maxTimeElapsed`\n    // older than `timestamp` and the time elapsed since the beginning of the hour for `timestamp` is not higher\n    // than `maxTimeElapsed`,  any allowed price must exist in the observation window for `timestamp`.\n    if (canBeThisWindow || mustBeThisWindow) {\n      PriceLibrary.PriceObservation storage observation = indexedPriceMap.priceMap[priceKey];\n      uint32 obsTimestamp = observation.timestamp;\n      if (\n        obsTimestamp != 0 &&\n        timestamp > obsTimestamp &&\n        timestamp - obsTimestamp <= maxTimeElapsed &&\n        timestamp - obsTimestamp >= minTimeElapsed\n      ) {\n        return (true, priceKey);\n      }\n      if (mustBeThisWindow) {\n        return (false, 0);\n      }\n    }\n\n    uint256 beginSearchTime = timestamp - minTimeElapsed;\n    priceKey = toPriceKey(beginSearchTime);\n    uint256 maxDistance = toPriceKey(maxTimeElapsed);\n    return indexedPriceMap.keyIndex.findLastSetKey(priceKey, maxDistance);\n  }\n}"
    },
    "temp-contracts/lib/KeyIndex.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./Bits.sol\";\n\n\n/**\n * @dev Library for indexing keys stored in a sequential mapping for easier\n * queries.\n *\n * Every set of 256 keys in the value map is assigned a single index which\n * records set values as bits, where 1 indicates the map has a value at a given\n * key and 0 indicates it does not.\n *\n * The 'value map' is the map which stores the values with sequential keys.\n * The 'key index' is the map which records the indices for every 256 keys\n * in the value map.\n *\n * The 'key index' is the mapping which stores the indices for each 256 values\n * in the map. For example, the key '256' in the value map would have a key\n * in the key index of `1`, where the 0th bit in the index records whether a\n * value is set in the value map .\n */\nlibrary KeyIndex {\n  using Bits for uint256;\n  using Bits for bytes;\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Compute the map key for a given index key and position.\n   * Multiplies indexKey by 256 and adds indexPosition.\n   */\n  function toMapKey(uint256 indexKey, uint256 indexPosition) internal pure returns (uint256) {\n    return (indexKey * 256) + indexPosition;\n  }\n\n  /**\n   * @dev Returns the key in the key index which stores the index for the 256-bit\n   * index which includes `mapKey` and the position in the index for that key.\n   */\n  function indexKeyAndPosition(uint256 mapKey)\n    internal\n    pure\n    returns (uint256 indexKey, uint256 indexPosition)\n  {\n    indexKey = mapKey / 256;\n    indexPosition = mapKey % 256;\n  }\n\n/* ========= Mutative Functions ========= */\n\n  /**\n   * @dev Sets a bit at the position in `indexMap` corresponding to `mapKey` if the\n   * bit is not already set.\n   *\n   * @param keyIndex Mapping with indices of set keys in the value map\n   * @param mapKey Position in the value map to mark as set\n   */\n  function markSetKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey\n  ) internal returns (bool /* didSetKey */) {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    // console.log(\"IPOS\", indexPosition);\n    uint256 localIndex = keyIndex[indexKey];\n    bool canSetKey = !localIndex.bitSet(indexPosition);\n    if (canSetKey) {\n      keyIndex[indexKey] = localIndex.setBit(indexPosition);\n    }\n    return canSetKey;\n  }\n\n/* ========= View Functions ========= */\n\n  /**\n   * @dev Returns a boolean indicating whether a value is stored for `mapKey` in the map index.\n   */\n  function hasKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey\n  ) internal view returns (bool) {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    uint256 localIndex = keyIndex[indexKey];\n    if (localIndex == 0) return false;\n    return localIndex.bitSet(indexPosition);\n  }\n\n  /**\n   * @dev Returns a packed uint16 array with the offsets of all set keys\n   * between `mapKeyFrom` and `mapKeyTo`. Offsets are relative to `mapKeyFrom`\n   */\n  function getEncodedSetKeysInRange(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKeyFrom,\n    uint256 mapKeyTo\n  ) internal view returns (bytes memory bitPositions) {\n    uint256 rangeSize = mapKeyTo - mapKeyFrom;\n    (uint256 indexKeyStart, uint256 indexPositionStart) = indexKeyAndPosition(mapKeyFrom);\n    (uint256 indexKeyEnd, uint256 indexPositionEnd) = indexKeyAndPosition(mapKeyTo);\n    // Expand memory too accomodate the maximum number of bits that could be found\n    // Length is 2*range because values are stored as uint16s\n    // 30 is added because 32 bytes are stored at a time and this would go past rangeSize*2\n    // if most bits are set\n    bitPositions = new bytes((2 * rangeSize) + 30);\n    // Set the length to 0, as it is used by the `writeSetBits` fn\n    assembly { mstore(bitPositions, 0) }\n    uint256 indexKey = indexKeyStart;\n    // Clear the bits before `indexPositionStart` so they are not included in the search result\n    uint256 localIndex = keyIndex[indexKey].clearBitsBefore(indexPositionStart);\n    uint16 offset = 0;\n    // Check each index until the last one is reached\n    while (indexKey < indexKeyEnd) {\n      // Relative index is set by adding provided `offset` to the bit index\n      bitPositions.writeSetBits(localIndex, offset);\n      indexKey += 1;\n      localIndex = keyIndex[indexKey];\n      offset += 256;\n    }\n    // Clear the bits after `indexPositionEnd` before searching for set bits\n    localIndex = localIndex.clearBitsAfter(indexPositionEnd);\n    bitPositions.writeSetBits(localIndex, offset);\n  }\n\n  /**\n   * @dev Find the most recent position before `mapKey` which the index map records\n   * as having a set value. Returns the key in the value map for that position.\n   *\n   * @param keyIndex Mapping with indices of set keys in the value map\n   * @param mapKey Position in the value map to look behind\n   * @param maxDistance Maximum distance between the found value and `mapKey`\n   */\n  function findLastSetKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey,\n    uint256 maxDistance\n  )\n    internal\n    view\n    returns (bool/* found */, uint256/* mapKey */)\n  {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    uint256 distance = 0;\n    bool found;\n    uint256 position;\n    uint256 localIndex;\n    // If the position is 0, we must go to the previous index\n    if (indexPosition == 0) {\n      require(indexKey != 0, \"KeyIndex::findLastSetKey:Can not query value prior to 0.\");\n      indexKey -= 1;\n      distance = 1;\n    } else {\n      localIndex = keyIndex[indexKey];\n      (found, position) = localIndex.nextLowestBitSet(indexPosition);\n      if (found) {\n        distance += indexPosition - position;\n      } else {\n        distance += indexPosition + 1;\n        indexKey -= 1;\n      }\n    }\n\n    while (!found && distance <= maxDistance) {\n      localIndex = keyIndex[indexKey];\n      if (localIndex == 0) {\n        if (indexKey == 0) return (false, 0);\n        distance += 256;\n        indexKey -= 1;\n      } else {\n        position = localIndex.highestBitSet();\n        distance += 255 - position;\n        found = true;\n      }\n    }\n    if (distance > maxDistance) {\n      return (false, 0);\n    }\n    return (true, toMapKey(indexKey, position));\n  }\n\n  /**\n   * @dev Find the next position after `mapKey` which the index map records as\n   * having a set value. Returns the key in the value map for that position.\n   *\n   * @param keyIndex Mapping with indices of set values in the value map\n   * @param mapKey Position in the value map to look ahead\n   * @param maxDistance Maximum distance between the found value and `mapKey`\n   */\n  function findNextSetKey(\n    mapping(uint256 => uint256) storage keyIndex,\n    uint256 mapKey,\n    uint256 maxDistance\n  )\n    internal\n    view\n    returns (bool/* found */, uint256/* mapKey */)\n  {\n    (uint256 indexKey, uint256 indexPosition) = indexKeyAndPosition(mapKey);\n    uint256 distance = 0;\n    bool found;\n    uint256 position;\n    uint256 localIndex;\n    if (indexPosition == 255) {\n      indexKey += 1;\n      position = indexPosition;\n      distance = 1;\n    } else {\n      localIndex = keyIndex[indexKey];\n      (found, position) = localIndex.nextHighestBitSet(indexPosition);\n      if (found) {\n        distance += position - indexPosition;\n      } else {\n        distance += 256 - indexPosition;\n        indexKey += 1;\n      }\n    }\n    while (!found && distance <= maxDistance) {\n      localIndex = keyIndex[indexKey];\n      if (localIndex == 0) {\n        distance += 256;\n        indexKey += 1;\n      } else {\n        position = localIndex.lowestBitSet();\n        distance += position;\n        found = true;\n      }\n    }\n    if (distance > maxDistance) {\n      return (false, 0);\n    }\n    return (true, toMapKey(indexKey, position));\n  }\n}\n"
    },
    "temp-contracts/OracleFallthrough.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/* ==========  Internal Libraries  ========== */\nimport \"./lib/PriceLibrary.sol\";\nimport \"./lib/FixedPoint.sol\";\nimport \"./lib/IndexedPriceMapLibrary.sol\";\n\n/* ==========  Internal Inheritance  ========== */\nimport \"./interfaces/IIndexedUniswapV2Oracle.sol\";\n\n\ncontract OracleFallthrough is Ownable {\n  using PriceLibrary for address;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n\n  IIndexedUniswapV2Oracle public immutable ethOracle;\n  IIndexedUniswapV2Oracle public immutable maticOracle;\n  address public immutable weth;\n  address public immutable wmatic;\n\n  mapping (address => bool) public useMatic;\n\n  constructor(\n    IIndexedUniswapV2Oracle _ethOracle,\n    IIndexedUniswapV2Oracle _maticOracle,\n    address _weth,\n    address _wmatic\n  ) public Ownable() {\n    ethOracle = _ethOracle;\n    maticOracle = _maticOracle;\n    weth = _weth;\n    wmatic = _wmatic;\n  }\n\n/* ==========  Mutative Functions  ========== */\n\n  function setUseMatic(address token, bool _useMatic) external onlyOwner {\n    require(token != wmatic && token != weth, \"OracleFallthrough::setUseMatic: Can not set useMatic for weth or matic.\");\n    useMatic[token] = _useMatic;\n  }\n\n  function setUseMaticMultiple(address[] calldata tokens, bool[] calldata useMatics) external onlyOwner {\n    uint256 len = tokens.length;\n    require(useMatics.length == len, \"OracleFallthrough::setUseMaticMultiple: Array lengths do not match.\");\n    for (uint256 i; i < len; i++) {\n      address token = tokens[i];\n      require(token != wmatic && token != weth, \"OracleFallthrough::setUseMaticMultiple: Can not set useMatic for weth or matic.\");\n      useMatic[token] = useMatics[i];\n    }\n  }\n\n  function updatePrice(address token) public returns (bool) {\n    (bool didUpdate, bool usedMatic) = _updatePrice(token);\n    if (usedMatic) _updateMaticPrice();\n    return didUpdate;\n  }\n\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory) {\n    uint256 len = tokens.length;\n    bool[] memory didUpdates = new bool[](len);\n    bool anyMatic;\n    for (uint256 i; i < len; i++) {\n      bool usedMatic;\n      (didUpdates[i], usedMatic) = _updatePrice(tokens[i]);\n      anyMatic = anyMatic || usedMatic;\n    }\n    if (anyMatic) _updateMaticPrice();\n    return didUpdates;\n  }\n\n/* ==========  Price Update Queries  ========== */\n\n  function canUpdatePrice(address token) public view returns (bool) {\n    return (useMatic[token] ? maticOracle : ethOracle).canUpdatePrice(token);\n  }\n\n  function canUpdatePrices(address[] calldata tokens) external view returns (bool[] memory) {\n    uint256 len = tokens.length;\n    bool[] memory canUpdates = new bool[](len);\n    for (uint256 i; i < len; i++) canUpdates[i] = canUpdatePrice(tokens[i]);\n  }\n\n/* ==========  Price Queries: Singular  ========== */\n\n  function computeTwoWayAveragePrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (PriceLibrary.TwoWayAveragePrice memory)\n  {\n    return _getTwoWayPrice(token, minTimeElapsed, maxTimeElapsed);\n  }\n\n  function computeAverageTokenPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (FixedPoint.uq112x112 memory priceAverage)\n  {\n    return _getTokenPrice(token, minTimeElapsed, maxTimeElapsed);\n  }\n\n  function computeAverageEthPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (FixedPoint.uq112x112 memory priceAverage)\n  {\n    return _getEthPrice(token, minTimeElapsed, maxTimeElapsed);\n  }\n\n/* ==========  Price Queries: Multiple  ========== */\n\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (PriceLibrary.TwoWayAveragePrice[] memory prices)\n  {\n    uint256 len = tokens.length;\n    prices = new PriceLibrary.TwoWayAveragePrice[](len);\n    for (uint256 i = 0; i < len; i++) {\n      prices[i] = _getTwoWayPrice(tokens[i], minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (FixedPoint.uq112x112[] memory averagePrices)\n  {\n    uint256 len = tokens.length;\n    averagePrices = new FixedPoint.uq112x112[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averagePrices[i] = _getTokenPrice(tokens[i], minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (FixedPoint.uq112x112[] memory averagePrices)\n  {\n    uint256 len = tokens.length;\n    averagePrices = new FixedPoint.uq112x112[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averagePrices[i] = _getEthPrice(tokens[i], minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n/* ==========  Value Queries: Singular  ========== */\n\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (uint144 /* averageValueInWETH */)\n  {\n    FixedPoint.uq112x112 memory tokenPrice = _getTokenPrice(token, minTimeElapsed, maxTimeElapsed);\n    return tokenPrice.mul(tokenAmount).decode144();\n  }\n\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (uint144 /* averageValueInToken */)\n  {\n    FixedPoint.uq112x112 memory ethPrice = _getEthPrice(token, minTimeElapsed, maxTimeElapsed);\n    return ethPrice.mul(wethAmount).decode144();\n  }\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (uint144[] memory averageValuesInWETH)\n  {\n    uint256 len = tokens.length;\n    require(\n      tokenAmounts.length == len,\n      \"OracleFallthrough::computeAverageEthForTokens: Tokens and amounts have different lengths.\"\n    );\n    averageValuesInWETH = new uint144[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averageValuesInWETH[i] = _getTokenPrice(\n        tokens[i],\n        minTimeElapsed,\n        maxTimeElapsed\n      ).mul(tokenAmounts[i]).decode144();\n    }\n  }\n\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    external\n    view\n    returns (uint144[] memory averageValuesInWETH)\n  {\n    uint256 len = tokens.length;\n    require(\n      wethAmounts.length == len,\n      \"OracleFallthrough::computeAverageTokensForEth: Tokens and amounts have different lengths.\"\n    );\n    averageValuesInWETH = new uint144[](len);\n    for (uint256 i = 0; i < len; i++) {\n      averageValuesInWETH[i] = _getEthPrice(\n        tokens[i],\n        minTimeElapsed,\n        maxTimeElapsed\n      ).mul(wethAmounts[i]).decode144();\n    }\n  }\n\n\n/* ==========  Internal Functions  ========== */\n\n  function _updateMaticPrice() internal {\n    ethOracle.updatePrice(wmatic);\n  }\n\n  function _getTwoWayPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (PriceLibrary.TwoWayAveragePrice memory)\n  {\n    if (token == weth) {\n      return PriceLibrary.TwoWayAveragePrice(\n        FixedPoint.encode(1)._x,\n        FixedPoint.encode(1)._x\n      );\n    }\n    if (useMatic[token]) {\n      PriceLibrary.TwoWayAveragePrice memory tokenPrice = maticOracle.computeTwoWayAveragePrice(token, minTimeElapsed, maxTimeElapsed);\n      PriceLibrary.TwoWayAveragePrice memory maticPrice = ethOracle.computeTwoWayAveragePrice(wmatic, minTimeElapsed, maxTimeElapsed);\n      tokenPrice.priceAverage = FixedPoint.uq112x112(tokenPrice.priceAverage).mul(\n        FixedPoint.uq112x112(maticPrice.priceAverage)\n      )._x;\n      tokenPrice.ethPriceAverage = FixedPoint.uq112x112(tokenPrice.ethPriceAverage).mul(\n        FixedPoint.uq112x112(maticPrice.ethPriceAverage)\n      )._x;\n      return tokenPrice;\n    } else {\n      return ethOracle.computeTwoWayAveragePrice(token, minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  function _getTokenPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (FixedPoint.uq112x112 memory)\n  {\n    if (token == weth) {\n      return FixedPoint.fraction(1, 1);\n    }\n    if (useMatic[token]) {\n      FixedPoint.uq112x112 memory tokenPrice = maticOracle.computeAverageTokenPrice(token, minTimeElapsed, maxTimeElapsed);\n      FixedPoint.uq112x112 memory maticPrice = ethOracle.computeAverageTokenPrice(wmatic, minTimeElapsed, maxTimeElapsed);\n      return tokenPrice.mul(maticPrice);\n    } else {\n      return ethOracle.computeAverageTokenPrice(token, minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  function _getEthPrice(\n    address token,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  )\n    internal\n    view\n    returns (FixedPoint.uq112x112 memory)\n  {\n    if (token == weth) {\n      return FixedPoint.fraction(1, 1);\n    }\n    if (useMatic[token]) {\n      FixedPoint.uq112x112 memory maticPriceToken = maticOracle.computeAverageEthPrice(token, minTimeElapsed, maxTimeElapsed);\n      FixedPoint.uq112x112 memory ethPriceMatic = ethOracle.computeAverageEthPrice(wmatic, minTimeElapsed, maxTimeElapsed);\n      return maticPriceToken.mul(ethPriceMatic);\n    } else {\n      return ethOracle.computeAverageEthPrice(token, minTimeElapsed, maxTimeElapsed);\n    }\n  }\n\n  function _updatePrice(address token) internal returns (bool didUpdate, bool usedMatic) {\n    usedMatic = useMatic[token];\n    didUpdate = (usedMatic ? maticOracle : ethOracle).updatePrice(token);\n  }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}